## 1035. 插入与归并
根据维基百科的定义：

插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。

归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。

现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？

**输入格式：**
输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。
f
**输出格式：**
首先在第 1 行中输出`Insertion Sort`表示插入排序、或`Merge Sort`表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。

**输入样例1：**
>10  
3 1 2 8 7 5 9 4 6 0  
1 2 3 7 8 5 9 4 6 0  

**输出样例1：**
>Insertion Sort  
1 2 3 5 7 8 9 4 6 0  

**输入样例2：**
>10  
3 1 2 8 7 5 9 4 0 6  
1 3 2 8 5 7 4 9 0 6  

**输出样例2：**
>Merge Sort  
1 2 3 8 4 5 7 9 0 6  

---
- 要理解好插入排序和归并排序
	- 插入排序：按顺序取元素，进行插入排序。**未排序部分和初始序列一定相同**
	- 归并排序：有序子序列的元素个数必然为$2^n$，**末尾不足数量的子序列同样需要排序**
- **数量掌握好**`qsort()`函数，例如对部分元素的排序，**函数第一个参数实质是元素的地址**
- 显然是否为插入排序更容易判断，因此将其作为判断排序类型的切入点
	


```c
#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a,const void *b) {//元素的比较函数 
	return *(int *)a - *(int *)b;
}
int main() {
	int N;
	scanf("%d", &N);
	int arr[2][N];
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < N; j++) {
			scanf("%d", &arr[i][j]);
		}
	}
	int cnt_order =  1;//有序的数量
	for (int i = 0; i < N - 1; i++) {//统计中间序列有序的数量 
		if (arr[1][i] > arr[1][i+1]) {
			break;
		}
		cnt_order++;
	} 
	int isInsert = 1;//是否为插入排序 
	for (int i = cnt_order; i < N; i++) {//抓住插入排序的特点 ：未排序部分和初始序列一定相同！
		if (arr[0][i] != arr[1][i]) {
			isInsert = 0;
			break;
		} 
	} 
	if (isInsert) {//插入排序 
		printf("Insertion Sort\n");
		qsort(arr[0], ++cnt_order, sizeof(int), cmp); 
	} else {//归并排序 
		printf("Merge Sort\n");
		int k = 1, flag = 1;//有序子序列中的元素数量，循环的标记 
        while(flag) {//循环直到 初始序列变为中间序列后，再归并一次 
            flag = 0;
            for (int i = 0; i < N; i++) {//遍历两个序列 
                if (arr[0][i] != arr[1][i]) {//如果有元素不同，令flag为1 
                    flag = 1;
                    break; 
                }
            }
            k *= 2;//有序子序列的元素个数 
            int i;
            for (i = 0; i < N / k; i++) {//需要归并的次数 
				qsort(&arr[0][i*k], k, sizeof(int), cmp);//对数组部分元素 归并排序 
			} 
            qsort(&arr[0][i*k], N - i * k, sizeof(int), cmp);//对末尾 不足有序子序列数量的元素排序 
        }
	}
	for(int i = 0; i < N-1; i++) {//输出数组 
		printf("%d ", arr[0][i]);
	}
	printf("%d\n", arr[0][N-1]);
	return 0;
}
```