## 1003. 我要通过！
“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。

得到“答案正确”的条件是：

1. 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；
2. 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；
3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。
现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。

**输入格式：** 每个测试输入包含1个测试用例。第1行给出一个自然数n (`<10`)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。

**输出格式：** 每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。

**输入样例：**
>8  
PAT  
PAAT  
AAPATAA  
AAPAATAAAA  
xPATx  
PT  
Whatever  
APAAATAA  

**输出样例：**
>YES  
YES  
YES  
YES  
NO  
NO  
NO  
NO  

---
```c
#include <stdio.h>
#include <string.h>
#define LEN 100

int main() {
	int cnt_str = 0;
	scanf("%d", &cnt_str); //获取测试用例的个数

	while (cnt_str > 0) {
		char str[LEN]; // 用于储存字符串的数组	
		scanf("%s", str);
		
		int cnt_A = 0, cnt_P = 0, cnt_T = 0;
		int pos_P = 0, pos_T = 0; //设置P、T的下标 
		
		for (int i = 0; i < strlen(str); i++) {
			if (str[i] == 'P') {
				pos_P = i; //记录P的下标 
				cnt_P++;
			}else if (str[i] == 'A') {
				cnt_A++; //记录A的数量 
			}else if (str[i] == 'T') {
				pos_T = i; // 记录T的下标 
				cnt_T++;
			}
		}
		//如果字符串的长度是 P+A+T 
		if ( cnt_P + cnt_A + cnt_T == strlen(str)) {
			int l_A = 0, c_A = 0, r_A = 0; // 声明左、中、右 字符A的数量 
			l_A = pos_P;
			c_A = pos_T - pos_P - 1;
			r_A = strlen(str) - pos_T - 1;
			if (c_A > 0 && l_A * c_A == r_A) {// 如果A的数量 右=左*中 
				printf("%s\n", "YES");
				cnt_str--;
				continue;
			}
		}  
		printf("%s\n", "NO");
		cnt_str--;
	} 
	return 0;
} 
```