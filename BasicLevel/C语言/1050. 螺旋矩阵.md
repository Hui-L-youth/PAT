## 1050. 螺旋矩阵
本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。

**输入格式：**
输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过$10^4$，相邻数字以空格分隔。

**输出格式：**
输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。

**输入样例：**
>12  
37 76 20 98 76 42 53 95 60 81 58 93  
**输出样例：**
>98 95 93  
42 37 81  
53 20 76  
58 60 76  

---
- 先对输入的数组排序
- 螺旋矩阵的行列数确定的关键：**m−n 取所有可能值中的最小值**，通过sqrt函数，开方再遍历，能最快地得到n
- 螺旋矩阵的填充顺序 上 → 右 → 下 → 左
	1. 用二维数组存储螺旋矩阵
	2. 遍历填充二维数组，**以二维数组的圈数作为遍历的次数**，分析可知圈数为`n / 2 + n % 2`（n <= m，每少一圈，列数-2）
	3. 注意填充之后，对未填充的最上行、最右列、最下行、最左列进行更新
	4. **每遍历一次行/列后**，判断是否已经遍历完所有数，跳出循环（避免后续的错误覆盖，时间的浪费）

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int cmp(const void *a, const void *b) {//降序排序 
	return *(int *)b - *(int *)a;
}
int main(){
	int N, n, m;
	scanf("%d", &N);
	int  arr[N];
	for (int i = 0; i < N; i++){
		scanf("%d", &arr[i]);
	}
	qsort(arr, N, sizeof(int), cmp);
	for (int i = sqrt((double)N); i >= 1; i--) {
		if (N % i == 0) {
			n = i;
			break;
		}
	}
	m = N / n;
	int matrix[m][n]; 
	int urow = 0, drow = m - 1, lcol = 0, rcol = n - 1, i = 0;
	for (int k = n / 2 + n % 2; k >= 0; k--) { //从外到里遍历的圈数 
		for (int j = lcol; j <= rcol; j++, i++) {//遍历最上行 
			matrix[urow][j] = arr[i];
		}
		if (i == N) {
			break;
		}
		urow++;//第一层遍历完毕 
		for (int j = urow; j <= drow; j++, i++) {//遍历最右列 
			matrix[j][rcol] = arr[i];
		}
		if (i == N) {
			break;
		}
		rcol--;//最后一列遍历完毕 
		for (int j = rcol; j >= lcol; j--, i++) {//倒序遍历最下行 
			matrix[drow][j] = arr[i]; 
		}
		if (i == N) {
			break;
		}
		drow--;//最后一行遍历完毕 
		for (int j = drow; j >= urow; j--, i++) {//倒序遍历最左的列 
			matrix[j][lcol] = arr[i];
		} 
		if (i == N) {
			break;
		}
		lcol++;//最左列遍历完毕 
	} 
	for (int i = 0; i < m; i++) { //输出矩阵
		for (int j = 0; j < n; j++) {
			if (j == n - 1) {
				printf("%d\n", matrix[i][j]);
			} else {
				printf("%d ", matrix[i][j]);
			}
		}
	}
	return 0;
}
```