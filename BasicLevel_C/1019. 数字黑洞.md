## 1019. 数字黑洞
给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。

例如，我们从6767开始，将得到

7766 - 6677 = 1089  
9810 - 0189 = 9621  
9621 - 1269 = 8352  
8532 - 2358 = 6174  
7641 - 1467 = 6174  
... ...

现给定任意4位正整数，请编写程序演示到达黑洞的过程。

**输入格式：**
输入给出一个(0, 10000)区间内的正整数N。

**输出格式：**
如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。

**输入样例1：**
>6767

**输出样例1：**
>7766 - 6677 = 1089  
9810 - 0189 = 9621  
9621 - 1269 = 8352  
8532 - 2358 = 6174  

**输入样例2：**
>2222  

**输出样例2：**
>2222 - 2222 = 0000

---
```c
#include <stdio.h>

int calculate(int num, int *arr, int len);
int main() {
	int num;
	scanf("%d", &num);
	int arr[4] = {0};//数组
	int result = 0;
	result = calculate(num, arr, 4);
	while (result != 0 && result != 6174) {
		result = calculate(result, arr, 4);
	}
	return 0; 
}
int calculate(int num, int *arr, int len) {
	int i = 0, max = 0, min = 0;//数组下标，最大值，最小值 
	while (num / 10 != 0 || num % 10 != 0) { 
		arr[i++] = num % 10;
		num /= 10;
	} 
	for (int i = 0; i < len; i++) {//降序排序 
		for (int j = 0; j < len - i - 1; j++) {
			if (arr[j] < arr[j+1]) {
				int temp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = temp;
			}
		} 
	}
	max = arr[0] * 1000 + arr[1] * 100 + arr[2] * 10 + arr[3];
	min = arr[0] + arr[1] * 10 + arr[2] * 100 + arr[3] * 1000;
	int result = max - min;
	if (result == 0) {
		printf("%04d - %04d = 0000\n", max, min);
	} else {
		printf("%04d - %04d = %04d\n", max, min, result);
	}
	return result;
}
```