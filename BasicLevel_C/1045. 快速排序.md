## 1045. 快速排序
著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？

例如给定 N = 5, 排列是1、3、2、4、5。则：

1 的左边没有元素，右边的元素都比它大，所以它可能是主元；
尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；
尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；
类似原因，4 和 5 都可能是主元。
因此，有 3 个元素可能是主元。

**输入格式：**
输入在第 1 行中给出一个正整数 N（$≤10^​5$）；第 2 行是空格分隔的 N 个不同的正整数，每个数不超过$10^​9$。

**输出格式：**
在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。

**输入样例：**
>5  
1 3 2 4 5  

**输出样例：**
>3  
1 4 5  

---
- 可能的主元：**前面的最大值比自己小；后面的最小值比自己大**
	- **将上述特征通过创建两个新数组来表现**

```c
#include <stdio.h>

int main() {
    int N, cnt = 0;
    scanf("%d", &N);
    int arr[N], lmax[N], rmin[N];
    for(int i = 0; i < N; i++) {
    	scanf("%d", &arr[i]);
	}
	lmax[0] = arr[0];
	rmin[N-1] = arr[N-1];
    for(int i = 1; i < N; i++) {//找出在元素 左边最大的元素 
    	if (arr[i] > lmax[i-1]) {//如果当前元素>左边最大的元素 ,令当前元素左侧最大的元素为自身 
    		lmax[i] = arr[i];
		} else {
			lmax[i] = lmax[i-1];
		}
	}
    for(int i = N - 2; i >= 0; i--) {//找出在元素 右边最小的元素 
    	if (arr[i] < rmin[i+1]) {//如果当前元素 < 右边最小的元素 ,令当前元素右侧最大的元素为自身 
    		rmin[i] = arr[i];
		} else {
			rmin[i] = rmin[i+1];
		}
	}
    for(int i = 0; i < N; i++) {//统计可能是主元的数量 
        if(arr[i] == lmax[i] && arr[i] == rmin[i]) {//如果左侧最大的元素 和 右侧最小的元素 都是自身，就可能是主元 
        	cnt++;
		} else {
			arr[i] = 0;
		}
    }
    printf("%d\n", cnt);
    for(int i = 0; i < N && cnt > 0; i++) {
    	if(arr[i] != 0) {//可能是主元 
			printf("%d", arr[i]);
			if (cnt > 1) {
    			printf(" ");
			}
    		cnt--;
		}
	}
    printf("\n");
    return 0;
}
```