## 1008. 数组元素循环右移问题
一个数组A中存有$N$（$N>0$）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移$M$（$M>=0$）个位置，即将A中的数据由（$A_0$ $A_1$ …… $A_{N-1}$）变换为（$A_{N-M}$ …… $A_{N-1}$ $A_0$ $A_1$ …… $A_{N-M-1}$）（最后$M$个数循环移至最前面的$M$个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

**输入格式：** 每个输入包含一个测试用例，第1行输入$N$（$1<=N<=100$）、$M$（$M>=0$）；第2行输入$N$个整数，之间用空格分隔。

**输出格式：** 在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。

**输入样例：**
>6 2  
1 2 3 4 5 6

**输出样例：**
>5 6 1 2 3 4

---
```c
#include <stdio.h>

void reverse(int *arr, int left, int right); 
int main() {
	int size, d;//声明数组大小和右移 
	scanf("%d %d", &size, &d); 
	int arr[size];//创建数组 
	d = d % size;// 使 d < size，避免出错，达到同样的位移结果 
	for (int i = 0; i < size; i++) {//读入数字 
		scanf("%d", &arr[i]); 
	} 
	reverse(arr, 0, size-1);//倒置数组 
	reverse(arr, 0, d-1);//倒置前d个数 
	reverse(arr, d, size-1);//倒置之后的所有数 
	//输出 
	for (int i = 0; i < size; i++) {
		if(i != 0) {
			printf(" ");
		}
		printf("%d", arr[i]);
	} 
	return 0; 
}
void reverse(int *arr, int left, int right) {//倒置数组中部分元素的函数，参数依次为 数组，起始下标，终止下标
	int temp;
	for (int i = 0; i < (right - left + 1) / 2; i++) { 
		temp = arr[left+i];
		arr[left+i] = arr[right-i];
		arr[right-i] = temp; 
	}
}
```