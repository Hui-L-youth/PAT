## 1030. 完美数列
给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M <= m \* p，则称这个数列是完美数列。

现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。

**输入格式：**
输入第一行给出两个正整数N和p，其中N（$<= 10^5$）是输入的正整数的个数，p（$<= 10^9$）是给定的参数。第二行给出N个正整数，每个数不超过$10^9$。

**输出格式：**
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。

**输入样例：**
>10 8  
2 3 20 4 5 1 6 7 8 9  

**输出样例：**
>8  

---
- 用qsort函数排序时间复杂度低 
`<stdlib.h> void qsort(void *base,size_t nelem,size_t width,int (*Comp)(const void *,const void *));`
- 遍历时，高效地判断完美数列

```c
#include <stdio.h>
#include <stdlib.h>

int cmp(const void * a, const void * b) {
	//qsort的比较函数如果返回（第一个值大于第二个值时返回正数），则为递增 
	return *(long int *)a - *(long int *)b;
}
int main() {
	int N, max = 0;//正整数个数, 完美数列最多含有的数字个数 
	long int p;//参数p 
	scanf("%d %ld", &N, &p);
	long int arr[N];
	for (int i = 0; i < N; i++) {
		scanf("%ld", &arr[i]);
	} 
	//升序排序 
	qsort(arr, N, sizeof(long int),cmp);
	for (int i = 0; i < N; i++) {
		for (int j = i + max; j < N; j++) {// 超过最大数量的数列，是否为完美数列
			if(arr[j] <= (arr[i] * p)) {
				if (max < (j - i + 1)) {
					max = j - i + 1;
				}
			} else {//如果不是，后续元素更大，更不可能是，跳出循环即可
				break;
			}
		} 
	}
	printf("%d\n", max);
	return 0;
}
```