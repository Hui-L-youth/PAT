## 1025. 反转链表
给定一个常数K以及一个单链表L，请编写程序将L中每K个结点反转。例如：给定L为1→2→3→4→5→6，K为3，则输出应该为3→2→1→6→5→4；如果K为4，则输出应该为4→3→2→1→5→6，即最后不到K个元素不反转。

**输入格式：**
每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址、结点总个数正整数N($<= 10^5$)、以及正整数K(<=N)，即要求反转的子链结点的个数。结点的地址是5位非负整数，NULL地址用-1表示。

接下来有N行，每行格式为：

Address Data Next

其中Address是结点地址，Data是该结点保存的整数数据，Next是下一结点的地址。

**输出格式：**
对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。

**输入样例：**
>00100 6 4  
00000 4 99999  
00100 1 12309  
68237 6 -1  
33218 3 00000  
99999 5 68237  
12309 2 33218  

**输出样例：**
>00000 4 33218  
33218 3 12309  
12309 2 00100  
00100 1 99999  
99999 5 68237  
68237 6 -1  

---

- **通过数组下标来表示下标，便于排序**
- **考虑存在无效节点的情况**

```c
#include <stdio.h>

typedef struct {
	int address;//节点地址
	int data; //整数数据
	int next;//下一节点的地址  
} Node; 
int main() {
	int addr, N, K;//读取首地址，节点数量，反转个数 
	scanf("%d %d %d", &addr, &N, &K);
	Node *origin = (Node *)malloc(sizeof(Node) * 100001);//创建初始单链表,反转后的单链表 
	Node *sort = (Node *)malloc(sizeof(Node) * 100001);
	for (int i = 0; i < N; i++) {//读取节点
		Node temp; 
		scanf("%d %d %d", &temp.address, &temp.data, &temp.next);
		origin[temp.address] = temp;
	}
	for (int i = 0; i < N; i++) {//排序 
		sort[i] = origin[addr];
		addr = sort[i].next;
		if (addr == -1) {
			N = i + 1;//可能有无效的节点，需要更新链表中节点的数量 
			break;
		}
	} 	
	for (int i = 0; i < N / K; i++) {//反转 
		for (int j = 0; j < K / 2; j++) {
			Node temp;
			temp = sort[j+i*K];
			sort[j+i*K] = sort[K-1-j+i*K];
			sort[K-1-j+i*K] = temp;
		}
	}
	for (int i = 0; i < N; i++) {
		if(i != N - 1) {
			sort[i].next = sort[i+1].address;
			printf("%05d %d %05d\n", sort[i].address, sort[i].data, sort[i].next);
		} else {
			sort[i].next = -1;
			printf("%05d %d %d\n", sort[i].address, sort[i].data, sort[i].next);
		}
	} 
	return 0;
}
```