## 1048. 数字加密
本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。

**输入格式：**
输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。

**输出格式：**
在一行中输出加密后的结果。

**输入样例：**
>1234567 368782971  

**输出样例：**
>3695Q8118  

---
- **当加密的正整数A比B长时，需要默认B的不足位数为0，继续进行计算**（题目输入样例不足导致的理解坑）
- 待优化

```c
#include <stdio.h>
#include <string.h>

int main() {
    char A[101], B[101], result[101] = {0};//加密整数A 和 B，结果 
	scanf("%s %s", A, B);
	char num[13] = "0123456789JQK";
	int isodd = 1;//是否奇数位 
	int result_len = strlen(A) >= strlen(B) ? strlen(A) : strlen(B); 
	for(int i = strlen(B) - 1, j = strlen(A) - 1; i >= 0 && j >= 0; i--, j--) {//A、B对应位都存在时 
		if (isodd) {//奇数位 
			result[--result_len] = num[(A[j] + B[i] - 2 * '0') % 13];
			isodd = 0;
		} else {//偶数位
			result[--result_len] =  (B[i] - A[j]) < 0 ? num[B[i] - A[j] + 10] : num[B[i] - A[j]];
			isodd = 1;
		}
	}
	int Alonger = strlen(A) - strlen(B);
	if (Alonger < 0) {//如果整数比加密的整数长 
		for (int i = 0; i < strlen(B) - strlen(A); i++) {
			result[i] = B[i];
		}
	} else {
		while (Alonger-- > 0) {
			if (isodd) {
				result[Alonger] = A[Alonger];
				isodd = 0;
			} else {
				if (A[Alonger] == '0') {
					result[Alonger] = '0';
				} else {
					result[Alonger] = 10 + ('0' - A[Alonger]) + '0';
				}
				isodd = 1;
			}
		} 
	}
	printf("%s\n", result);
    return 0;
}
```