二分查找的前提：**数组有序**。

## 普通实现
	public static int binarySearch(int key, int[] arr) {
		int min, max, mid;
		min = 0;// 最小值的下标
		max = arr.length - 1;// 最大值下标
		mid = (min + max) / 2;// 中间值下标

		while (key != arr[mid]) {//当key值和中间值不等时
			if (key > mid) {//key值比中间值大，修改查找范围的最小值
				min = mid + 1;
			} else if (key < arr[mid]) {//key值比中间值小，修改查找范围的最大值
				max = mid -1;
			}
			if(max < min) {//出现这种情况是因为 key 比之前的 max大 或者 比之前的min小
				return -1;//不存在
			}
		}
		return mid;
	}


二分查找的结果：

- 查找过程中，**发现数组中存在对应的值**；
- **一直查找到 max < min，才能确认数组中不存在对应的值**。
***

## 递归实现  

- 递归方法的**第一条语句总是一个包含`return`的条件语句**
- 上述的条件语句即是**收敛到最简单的情况**时的语句  


    	public static int binarySearch(int key, int[] arr) {
    		return binarySearch(key, arr, 0, arr.length - 1);
    	}
    
    	public static int binarySearch(int key, int[] arr, int min, int max) {
    		if (min > max) {// 最简单的情况之一，数组中不存在key
    			return -1;
    		}
    		int mid = (min + max) / 2;
    		if (key == arr[mid]) {// 最简单的情况之二，数组存在key
    			return mid;
    		} else if (key > arr[mid]) {// key比中间值大，修改min 递归
    			return binarySearch(key, arr, mid + 1, max);
    		} else {// key比中间值小，修改max 递归
    			return binarySearch(key, arr, min, mid - 1);
    		}
    	}