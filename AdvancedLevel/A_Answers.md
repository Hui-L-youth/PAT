

---

| 题目                                       | 答案                               | 解题关键                                                     | 题型                                                         |
| ------------------------------------------ | :--------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1001** **A+B Format**                    | [C++](/AdvancedLevel/C++/1001.cpp) | 从**数字高位(字符串低位)开始**，需要添加`,`的位置满足`(i + 1) % 3 == len % 3` **且 不是最后一位** |                                                              |
| **1002** **A+B for Polynomials**           | [C++](/AdvancedLevel/C++/1002.cpp) | 非零系数项个数的统计                                         |                                                              |
| **1004** **Counting Leaves**               | [C++](/AdvancedLevel/C++/1004.cpp) | 1. 利用数组**存储每层的叶结点个数**<br />2. 根据**出队结点的层数，获取最大层数**，遍历输出每层叶结点个数<br /> | 树的遍历（BFS）                                              |
| **1005** **Spell It Right**                | [C++](/AdvancedLevel/C++/1005.cpp) | \                                                            |                                                              |
| **1006** **Sign In and Sign Out**          | [C++](/AdvancedLevel/C++/1006.cpp) | 方法类似 乙级1028 人口普查                                   |                                                              |
| **1009** **Product of Polynomials**        | [C++](/AdvancedLevel/C++/1009.cpp) | 第二个多项式可边读边处理                                     |                                                              |
| **1010** **Radix**                         | [C++](/AdvancedLevel/C++/1010.cpp) | 1. **基数上界为 已确认数字的十进制大小 + 1 与 下界中的较大值（确保不会出现多个解(而且基数不确定的数，只有一位数的时候才可能多个解) )**<br />2. 基数过大时，数值转换为十进制会发生**上溢，存储结果为负数** | 二分                                                         |
| **1011** **World Cup Betting**             | [C++](/AdvancedLevel/C++/1011.cpp) | \                                                            |                                                              |
| **1012** **The Best Rank**                 | [C++](/AdvancedLevel/C++/1012.cpp) | 1. **利用全局变量设计cmp函数**<br />2. 通过**记录所有科目的排名**，最后选出最好的排名以及对应科目<br />3. 相同分数者排名相同，**下一不同分数者**排名为**数组下标+1** |                                                              |
| **1013** **Battle Over Cities**            | [C++](/AdvancedLevel/C++/1013.cpp) | 1. 问题等价于求 一个无向图**去掉一个结点后，连通分量的数量**<br />2. **`cin`会超时，需要改为`scanf`**，邻接矩阵和邻接表都可存储图<br />3. **每次输入被占领的城市之前，要重置城市的访问状态为未访问**<br />4. 将**失去的城市标记为已访问**，即可**达到失去的效果(没有公路可以到达)** | 图的遍历（DFS/BFS/**并查集**）                               |
| **1016** **Phone Bills**                   | [C++](/AdvancedLevel/C++/1016.cpp) | **（待优化）**<br />1. **通话记录统一先排序**后处理<br />2. **连续的两个通话记录，判断是否为 同一用户 且 为先通话后挂断的状态**<br />3. **通话时长的统计方法**<br />4. 单位美分cents 要转换为 美元$ |                                                              |
| **1019** **General Palindromic Number**    | [C++](/AdvancedLevel/C++/1019.cpp) | \                                                            |                                                              |
| **1020** **Tree Traversals**               | [C++](/AdvancedLevel/C++/1020.cpp) | \                                                            | 二叉树的遍历(后序遍历序列 + 中序遍历序列 确定二叉树；层序遍历) |
| **1025** **PAT Ranking**                   | [C++](/AdvancedLevel/C++/1025.cpp) | \                                                            |                                                              |
| **1027** **Colors in Mars**                | [C++](/AdvancedLevel/C++/1027.cpp) | \                                                            |                                                              |
| **1028** **List Sorting**                  | [C++](/AdvancedLevel/C++/1028.cpp) | \                                                            |                                                              |
| **1031** **Hello World for U**             | [C++](/AdvancedLevel/C++/1031.cpp) | 根据 n1和n3为  $\leq$ n2，且满足 n1+n2+n3 = N+2 的最大值，求出n1，n2，n3 |                                                              |
| **1032** **Sharing**                       | [C++](/AdvancedLevel/C++/1032.cpp) | \                                                            | 静态链表(基于散列)                                           |
| **1033** **To Fill or Not to Fill**        | [C++](/AdvancedLevel/C++/1033.cpp) | **能到达的距离**内，**由近到远遍历**，有三种情况：<br /><br />1. 最近距离的加油站都到不了<br />2. 出现油价比目前低的加油站，就直接去<br />    2.1 **油不够**，只加能刚好到达的油量<br />    2.2 **不用加油**<br />3. 没有更低价的加油站，就**加满油(能尽量少加更贵的油)**，去**价格相对 最低**的加油站 |                                                              |
| **1035** **Password**                      | [C++](/AdvancedLevel/C++/1035.cpp) | (待优化)                                                     |                                                              |
| **1036** **Boys vs Girls**                 | [C++](/AdvancedLevel/C++/1036.cpp) | \                                                            |                                                              |
| **1042** **Shuffling Machine**             | [C++](/AdvancedLevel/C++/1042.cpp) | **将扑克顺序号转为实际牌号的方式**                           |                                                              |
| **1043** **Is It a Binary Search Tree**    | [C++](/AdvancedLevel/C++/1043.cpp) | 1. **变长数组**存储输入序列，表示二叉树<br />2. 根据BST左子树所有结点的数据域 < 根结点的数据域，右子树所有结点的数据域 **≥** 根结点的数据域(**由输入样例得出大小关系**，镜像则相反)，**按照先序序列的特点(第一个结点为根结点)，获取左右子树的边界，判断是否符合先序序列，若符合**，则按照**左右根的顺序递归，将符合的根结点存入`vector`(获取后序序列)**<br />3. **若vecotr中元素数量 = 输入序列的元素数量(能顺利转换为BST的后序序列)，说明输入序列为先序序列** | 二叉搜索树BST                                                |
| **1046 Shortest Distance**                 | [C++](/AdvancedLevel/C++/1046.cpp) | 便于计算距离的方式                                           |                                                              |
| **1051** **Pop Sequence**                  | [C++](/AdvancedLevel/C++/1051.cpp) | 1. 可能会发生**堆栈溢出**<br />2. **栈顶元素和当前需要出栈的元素相同时，出栈。该判断之前必须先判断栈是否不为空(否则会报错)**<br />3. 标记出栈序列中待出栈元素下标，最终**标记只有超出序列下标，才可能是出栈序列** | 栈                                                           |
| **1052** **Linked List Sorting**           | [C++](/AdvancedLevel/C++/1052.cpp) | 存在**无有效结点**的情况                                     | 静态链表(基于散列)                                           |
| **1053** **Path of Equal Weight**          | [C++](/AdvancedLevel/C++/1053.cpp) | 1. 输出的路径序列要求降序，因此**在读入结点时**就将孩子节点**按权重降序**排序，这样，之后遍历时得到的路径即为降序<br /><br />2. 利用`vector`的`begin`和`end`函数获得`vector`的**首元素地址**和**尾后地址**，用于`sort`函数排序<br />3. 利用`vector`存储路径，在**递归子结点之前**，用`push_back`函数**将子结点加入路径**，递归**回溯后**，用`pop_back`**将先前加入的子结点移出路径** | 树的遍历（DFS）                                              |
| **1055** **The World's Richest**           | [C++](/AdvancedLevel/C++/1055.cpp) | **超时问题。要求输出的人数$\leq$100，通过筛去每个年龄多余的人解决** |                                                              |
| **1056** **Mice and Rice**                 | [C++](/AdvancedLevel/C++/1056.cpp) | 1. 输入的第二行是按老鼠的序号给出的重量。**第三行给出的是老鼠的序号，而不是按序号给出的比赛序号**<br />2. 用**队列记录老鼠的序号**(而不是记录老鼠的结构体，**有利于减少内存的占用**)，**晋级的老鼠重新入队**<br />3. 最后的分组中，老鼠数量可能不足(利用<cmath\>中的`ceil`函数**向上取整**) | 队列                                                         |
| **1058** **A+B in Hogwarts**               | [C++](/AdvancedLevel/C++/1058.cpp) | 题型同 乙级1037 在霍格沃茨找零钱<br />单位转换过程可能会超过int范围 |                                                              |
| **1062** **Talent and Virtue**             | [C++](/AdvancedLevel/C++/1062.cpp) | 设置flag作为考生的分类，便于所有考生**统一排序**             |                                                              |
| **1064** **Complete Binary Search Tree**   | [C++](/AdvancedLevel/C++/1064.cpp) | 1. 输入的元素**升序排序**，即为二叉树的**中序遍历序列**。<br />2. **静态写法**(**变长数组**)按照**层序存储**完全二叉排序树<br />3. 对二叉树进行**中序遍历**，依次**填入中序遍历序列的元素**即可得到层序存储的二叉树。注意：中序遍历时，二叉树数组**根结点的下标**：<br />        **若设为1**，则左右孩子结点下标为`root * 2`和`root * 2 + 2`；<br />        **若设为0**，则左右孩子结点下标为`root * 2 + 1`和`root * 2 + 2`<br />4. **顺序输出**二叉树数组元素即为**层序遍历**序列 | 二叉搜索树BST                                                |
| **1065** **A+B and C (64bit)**             | [C++](/AdvancedLevel/C++/1065.cpp) | **乙级1011** **A+B 和 C 进阶版**<br />**负数相加若溢出，可能得到0** |                                                              |
| **1066** **Root of AVL Tree**              | [C++](/AdvancedLevel/C++/1066.cpp) | 即写出**平衡二叉树的代码模板**<br />1. **新建结点的初始高度为1**<br />2. 获取树高时，注意**递归到空结点**时，**返回0**<br />3. 插入结点，递归过程中从**系统栈出栈后**：<br />        1) 平衡因子为2时，**树型可能为LR型或LL型**，LR型需要先对当前结点的**左子树**进行**右旋**；之后，LR型和LL型**都需要对当前结点进行右旋**<br />        2) 平衡因子为-2时，**树型可能为RL型或RR型**，RL型需要先对当前结点的**右子树**进行**左旋**；之后，RL型和RR型**都需要对当前结点进行左旋**<br />4. 左旋和右旋过程中要**及时更新树高** | 平衡二叉树                                                   |
| **1070** **Mooncake**                      | [C++](/AdvancedLevel/C++/1070.cpp) | 库存量和售价都应该定义为double类型                           |                                                              |
| **1073** **Scientific Notation**           | [C++](/AdvancedLevel/C++/1073.cpp) | 1. **利用正则表达式，分开读取 数字部分 和 指数部分**<br />2. 指数 < 0：整数部分必然为 0<br />3. 指数 >= 0：<br/>     - **仍有小数点，何时输出小数点**<br/>     - 没有小数点，后续输出0 |                                                              |
| **1074** **Reversing Linked List**         | [C++](/AdvancedLevel/C++/1074.cpp) | 1. 通过**数组下标来表示地址**，便于链接各个节点<br/> 2. 可能**存在无效结点**<br/>3. **只根据 链表顺序的地址 进行反转**，有利于节约开销 | 静态链表(基于散列)                                           |
| **1075** **PAT Judge**                     | [C++](/AdvancedLevel/C++/1075.cpp) | **(待优化)**<br />1. **不能编译**的提交**得分为0**<br />2. 没有提交过的答案需要输出为`-`，利用`<cstring>`中的`memset`函数，**为 得分数组 赋值 -1，表示没有提交过答案**<br />3. **没有任何一题通过编译 或 没有提交过答案的人**不记录排名，**设置 是否有通过编译的标识**，进行筛选<br />4. 排序**以 是否有通过编译 为 第一排序条件** |                                                              |
| **1077** **Kuchiguse**                     | [C++](/AdvancedLevel/C++/1073.cpp) | 1. **通过反转字符串，将后缀转换为前缀，便于比较**<br />2. getline()之前注意**读取换行符**。 |                                                              |
| **1079** **Total Sales of Supply Chain**   | [C++](/AdvancedLevel/C++/1079.cpp) | 1. **静态写法**表示树，即用数组下标指代结点<br />2. 结点的结构体中设有**货物量**变量，用来**判断是否为零售商**（本题采用了BFS；也可DFS） | 树的遍历（BFS/DFS）                                          |
| **1082** **Read Number in Chinese**        | [C++](/AdvancedLevel/C++/1082.cpp) | 1. **四位数字分为一节**，单位为个、万、亿<br />2. **一节中数字全为0**，则不输出**节的单位**<br />3. 节中**第一个非零数之前有0**，则输出**1个**0 |                                                              |
| **1084** **Broken Keyboard**               | [C++](/AdvancedLevel/C++/1084.cpp) | 待优化                                                       |                                                              |
| **1085** **Perfect Sequence**              | [C++](/AdvancedLevel/C++/1085.cpp) | \                                                            | two pointers                                                 |
| **1086** **Tree Traversals Again**         | [C++](/AdvancedLevel/C++/1086.cpp) | **先序**序列相当于**入栈**次序；**中序**序列相当于**出栈**次序 | 二叉树的遍历(先序遍历序列 + 中序遍历序列 确定二叉树；后序遍历) |
| **1089** **Insert or Merge**               | [C++](/AdvancedLevel/C++/1089.cpp) | 1. 插入排序：**未排序部分和初始序列一定相同**<br/> 2. 归并排序：**末尾不足数量的子序列同样需要排序**<br/> 3. **插入排序 更容易判断，将其作为判断排序类型的切入点**<br />4. 插入和归并排序的**实际操作由排序函数`sort`/`qsort`**代替 | 归并排序                                                     |
| **1090** **Highest Price in Supply Chain** | [C++](/AdvancedLevel/C++/1090.cpp) | 由于**不涉及结点的数据域**，可以直接**用`vector<int> child[maxn]`存放树** | 树的遍历（BFS/DFS）                                          |
| **1091** **Acute Stroke**                  | [C++](/AdvancedLevel/C++/1091.cpp) | 1. **设定相对当前位置的前后左右上下6个方向的增量**，便于枚举<br />2. 设置数组`inq`**记录当前位置是否入过队**<br />3. **越界、当前位置为0、已入过队的位置**无需再判断。<br />4. 在BFS函数中，**利用队列进行BFS**，使用STL的`queue`，`push`函数只将所选元素的**副本入队，后续对原元素的操作不改变队列中的副本**。 | 广度优先搜索                                                 |
| **1092** **To Buy or Not to Buy**          | [C++](/AdvancedLevel/C++/1092.cpp) | \                                                            |                                                              |
| **1093** **Count PAT's**                   | [C++](/AdvancedLevel/C++/1093.cpp) | 1. A前有P，后有T才能形成PAT；<br/>2. 当前A能构成的PAT数量 = 之前P的数量 * 之后T的数量<br/>3. 突破口：**先遍历一遍，获取T的数量** | 递推                                                         |
| **1098** **Insertion or Heap Sort**        | [C++](/AdvancedLevel/C++/1098.cpp) | 1. 用于**表示树的数组**，注意下标**从 0或1 开始，孩子结点表示的区别**<br />2. 插入排序：**未排序部分和初始序列一定相同**<br/>3. 堆排序：**后面的元素有序，前面无规律**<br/>4. **插入排序 更容易判断，将其作为判断排序类型的切入点**<br />4. **插入排序**的**实际操作可由排序函数`sort`**实现<br /><br />5. 要用堆排序得到**递增序列**，则需要建立**大根堆**<br />6. 堆排序**从后往前**找到**第一个 $<$ 堆顶**的元素，与堆顶元素交换，再**对整个堆向下调整**，即可得到下一步调整的序列 | 堆排序                                                       |
| **1099** **Build A Binary Search Tree**    | [C++](/AdvancedLevel/C++/1099.cpp) | **静态写法**表示树，解题方法和 A1064 基本一致                | 二叉搜索树BST                                                |
| **1101** **Quick Sort**                    | [C++](/AdvancedLevel/C++/1101.cpp) | 1. **可能的主元：左侧的最大值比自身小；右侧的最小值比自身大**<br />2. **输出即使没有主元，也得换行** | 递推                                                         |
| **1102** **Invert a Binary Tree**          | [C++](/AdvancedLevel/C++/1102.cpp) | 1. 题目给的是**结点编号**的关系，故**采用静态链表**存储二叉树<br />2. 反转二叉树即**每个结点的左右子树对换**，选择**后序**遍历 | 二叉树的遍历(静态链表；后序遍历；先序遍历；层序遍历)         |
| **1103** **Integer Factorization**         | [C++](/AdvancedLevel/C++/1103.cpp) | 1. 利用`vector`(**可根据`size`函数确认符合要求的元素个数**)，**预先存储所有 ≤ N的 元素(整数的P次幂值)**<br />2. **为了保证底数最大的序列被选中，从大到小遍历**<br />3. DFS函数的参数：**当前**元素下标，**已选**元素数量，**已选**元素之和，**已选**元素的底数之和<br />4. DFS函数的**递归边界**：已选元素数量为K且和为N<br />5. DFS函数的**递归调用**：**选择当前元素和不选择当前元素**<br />6. **剪枝**：**和超过N 或 已选元素数量超过K 或 遍历完底数序列**时，不必再递归 | 深度优先搜索DFS + 剪枝                                       |
| **1107** **Social Clusters**               | [C++](/AdvancedLevel/C++/1107.cpp) | 1. **根据共同(包括潜在的→有共同爱好的人另外的爱好)爱好**来确定潜在**朋友的集合**，利用`hobby[1001]`**记录 任意一个 拥有对应爱好的结点**，**便于合并操作**<br />2. 遍历各用户，**根据根结点统计各集合的人数**<br />3. 将集合**按包含人数降序**排序，再**遍历**即可**筛选统计出集合个数**<br />4. 路径压缩**可选** | 并查集                                                       |