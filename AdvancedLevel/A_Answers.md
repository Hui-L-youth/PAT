

---

| 题目                                    | 答案                               | 解题关键                                                     | 题型                                                         |
| --------------------------------------- | :--------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1001** **A+B Format**                 | [C++](/AdvancedLevel/C++/1001.cpp) | 从**数字高位(字符串低位)开始**，需要添加`,`的位置满足`(i + 1) % 3 == len % 3` **且 不是最后一位** |                                                              |
| **1002** **A+B for Polynomials**        | [C++](/AdvancedLevel/C++/1002.cpp) | 非零系数项个数的统计                                         |                                                              |
| **1005** **Spell It Right**             | [C++](/AdvancedLevel/C++/1005.cpp) | \                                                            |                                                              |
| **1006** **Sign In and Sign Out**       | [C++](/AdvancedLevel/C++/1006.cpp) | 方法类似 乙级1028 人口普查                                   |                                                              |
| **1009** **Product of Polynomials**     | [C++](/AdvancedLevel/C++/1009.cpp) | 第二个多项式可边读边处理                                     |                                                              |
| **1010** **Radix**                      | [C++](/AdvancedLevel/C++/1010.cpp) | 1. **基数上界为 已确认数字的十进制大小 + 1 与 下界中的较大值（确保不会出现多个解(而且基数不确定的数，只有一位数的时候才可能多个解) )**<br />2. 基数过大时，数值转换为十进制会发生**上溢，存储结果为负数** | 二分                                                         |
| **1011** **World Cup Betting**          | [C++](/AdvancedLevel/C++/1011.cpp) | \                                                            |                                                              |
| **1012** **The Best Rank**              | [C++](/AdvancedLevel/C++/1012.cpp) | 1. **利用全局变量设计cmp函数**<br />2. 通过**记录所有科目的排名**，最后选出最好的排名以及对应科目<br />3. 相同分数者排名相同，**下一不同分数者**排名为**数组下标+1** |                                                              |
| **1016** **Phone Bills**                | [C++](/AdvancedLevel/C++/1016.cpp) | **（待优化）**<br />1. **通话记录统一先排序**后处理<br />2. **连续的两个通话记录，判断是否为 同一用户 且 为先通话后挂断的状态**<br />3. **通话时长的统计方法**<br />4. 单位美分cents 要转换为 美元$ |                                                              |
| **1019** **General Palindromic Number** | [C++](/AdvancedLevel/C++/1019.cpp) | \                                                            |                                                              |
| **1020** **Tree Traversals**            | [C++](/AdvancedLevel/C++/1020.cpp) | \                                                            | 二叉树的遍历(后序遍历序列 + 中序遍历序列 确定二叉树；层序遍历) |
| **1025** **PAT Ranking**                | [C++](/AdvancedLevel/C++/1025.cpp) | \                                                            |                                                              |
| **1027** **Colors in Mars**             | [C++](/AdvancedLevel/C++/1027.cpp) | \                                                            |                                                              |
| **1028** **List Sorting**               | [C++](/AdvancedLevel/C++/1028.cpp) | \                                                            |                                                              |
| **1031** **Hello World for U**          | [C++](/AdvancedLevel/C++/1031.cpp) | 根据 n1和n3为  $\leq$ n2，且满足 n1+n2+n3 = N+2 的最大值，求出n1，n2，n3 |                                                              |
| **1032** **Sharing**                    | [C++](/AdvancedLevel/C++/1032.cpp) | \                                                            | 静态链表(基于散列)                                           |
| **1033** **To Fill or Not to Fill**     | [C++](/AdvancedLevel/C++/1033.cpp) | **能到达的距离**内，**由近到远遍历**，有三种情况：<br /><br />1. 最近距离的加油站都到不了<br />2. 出现油价比目前低的加油站，就直接去<br />    2.1 **油不够**，只加能刚好到达的油量<br />    2.2 **不用加油**<br />3. 没有更低价的加油站，就**加满油(能尽量少加更贵的油)**，去**价格相对 最低**的加油站 |                                                              |
| **1035** **Password**                   | [C++](/AdvancedLevel/C++/1035.cpp) | (待优化)                                                     |                                                              |
| **1036** **Boys vs Girls**              | [C++](/AdvancedLevel/C++/1036.cpp) | \                                                            |                                                              |
| **1042** **Shuffling Machine**          | [C++](/AdvancedLevel/C++/1042.cpp) | **将扑克顺序号转为实际牌号的方式**                           |                                                              |
| **1046 Shortest Distance**              | [C++](/AdvancedLevel/C++/1046.cpp) | 便于计算距离的方式                                           |                                                              |
| **1051** **Pop Sequence**               | [C++](/AdvancedLevel/C++/1051.cpp) | 1. 可能会发生**堆栈溢出**<br />2. **栈顶元素和当前需要出栈的元素相同时，出栈。该判断之前必须先判断栈是否不为空(否则会报错)**<br />3. 标记出栈序列中待出栈元素下标，最终**标记只有超出序列下标，才可能是出栈序列** | 栈                                                           |
| **1052** **Linked List Sorting**        | [C++](/AdvancedLevel/C++/1052.cpp) | 存在**无有效结点**的情况                                     | 静态链表(基于散列)                                           |
| **1055** **The World's Richest**        | [C++](/AdvancedLevel/C++/1055.cpp) | **超时问题。要求输出的人数$\leq$100，通过筛去每个年龄多余的人解决** |                                                              |
| **1056** **Mice and Rice**              | [C++](/AdvancedLevel/C++/1056.cpp) | 1. 输入的第二行是按老鼠的序号给出的重量。**第三行给出的是老鼠的序号，而不是按序号给出的比赛序号**<br />2. 用**队列记录老鼠的序号**(而不是记录老鼠的结构体，**有利于减少内存的占用**)，**晋级的老鼠重新入队**<br />3. 最后的分组中，老鼠数量可能不足(利用<cmath\>中的`ceil`函数**向上取整**) | 队列                                                         |
| **1058** **A+B in Hogwarts**            | [C++](/AdvancedLevel/C++/1058.cpp) | 题型同 乙级1037 在霍格沃茨找零钱<br />单位转换过程可能会超过int范围 |                                                              |
| **1062** **Talent and Virtue**          | [C++](/AdvancedLevel/C++/1062.cpp) | 设置flag作为考生的分类，便于所有考生**统一排序**             |                                                              |
| **1065** **A+B and C (64bit)**          | [C++](/AdvancedLevel/C++/1065.cpp) | **乙级1011** **A+B 和 C 进阶版**<br />**负数相加若溢出，可能得到0** |                                                              |
| **1070** **Mooncake**                   | [C++](/AdvancedLevel/C++/1070.cpp) | 库存量和售价都应该定义为double类型                           |                                                              |
| **1073** **Scientific Notation**        | [C++](/AdvancedLevel/C++/1073.cpp) | 1. **利用正则表达式，分开读取 数字部分 和 指数部分**<br />2. 指数 < 0：整数部分必然为 0<br />3. 指数 >= 0：<br/>     - **仍有小数点，何时输出小数点**<br/>     - 没有小数点，后续输出0 |                                                              |
| **1074** **Reversing Linked List**      | [C++](/AdvancedLevel/C++/1074.cpp) | 1. 通过**数组下标来表示地址**，便于链接各个节点<br/> 2. 可能**存在无效结点**<br/>3. **只根据 链表顺序的地址 进行反转**，有利于节约开销 | 静态链表(基于散列)                                           |
| **1075** **PAT Judge**                  | [C++](/AdvancedLevel/C++/1075.cpp) | **(待优化)**<br />1. **不能编译**的提交**得分为0**<br />2. 没有提交过的答案需要输出为`-`，利用`<cstring>`中的`memset`函数，**为 得分数组 赋值 -1，表示没有提交过答案**<br />3. **没有任何一题通过编译 或 没有提交过答案的人**不记录排名，**设置 是否有通过编译的标识**，进行筛选<br />4. 排序**以 是否有通过编译 为 第一排序条件** |                                                              |
| **1077** **Kuchiguse**                  | [C++](/AdvancedLevel/C++/1073.cpp) | 1. **通过反转字符串，将后缀转换为前缀，便于比较**<br />2. getline()之前注意**读取换行符**。 |                                                              |
| **1082** **Read Number in Chinese**     | [C++](/AdvancedLevel/C++/1082.cpp) | 1. **四位数字分为一节**，单位为个、万、亿<br />2. **一节中数字全为0**，则不输出**节的单位**<br />3. 节中**第一个非零数之前有0**，则输出**1个**0 |                                                              |
| **1084** **Broken Keyboard**            | [C++](/AdvancedLevel/C++/1084.cpp) | 待优化                                                       |                                                              |
| **1085** **Perfect Sequence**           | [C++](/AdvancedLevel/C++/1085.cpp) | \                                                            | two pointers                                                 |
| **1086** **Tree Traversals Again**      | [C++](/AdvancedLevel/C++/1086.cpp) | **先序**序列相当于**入栈**次序；**中序**序列相当于**出栈**次序 | 二叉树的遍历(先序遍历序列 + 中序遍历序列 确定二叉树；后序遍历) |
| **1089** **Insert or Merge**            | [C++](/AdvancedLevel/C++/1089.cpp) | 1. 插入排序：**未排序部分和初始序列一定相同**<br/> 2. 归并排序：**末尾不足数量的子序列同样需要排序**<br/> 3. **插入排序 更容易判断，将其作为判断排序类型的切入点**<br />4. 插入和归并排序的**实际操作由排序函数`sort`/`qsort`**代替 | 归并排序                                                     |
| **1091** **Acute Stroke**               | [C++](/AdvancedLevel/C++/1091.cpp) | 1. **设定相对当前位置的前后左右上下6个方向的增量**，便于枚举<br />2. 设置数组`inq`**记录当前位置是否入过队**<br />3. **越界、当前位置为0、已入过队的位置**无需再判断。<br />4. 在BFS函数中，**利用队列进行BFS**，使用STL的`queue`，`push`函数只将所选元素的**副本入队，后续对原元素的操作不改变队列中的副本**。 | 广度优先搜索                                                 |
| **1092** **To Buy or Not to Buy**       | [C++](/AdvancedLevel/C++/1092.cpp) | \                                                            |                                                              |
| **1093** **Count PAT's**                | [C++](/AdvancedLevel/C++/1093.cpp) | 1. A前有P，后有T才能形成PAT；<br/>2. 当前A能构成的PAT数量 = 之前P的数量 * 之后T的数量<br/>3. 突破口：**先遍历一遍，获取T的数量** | 递推                                                         |
| **1101** **Quick Sort**                 | [C++](/AdvancedLevel/C++/1101.cpp) | 1. **可能的主元：左侧的最大值比自身小；右侧的最小值比自身大**<br />2. **输出即使没有主元，也得换行** | 递推                                                         |
| **1102** **Invert a Binary Tree**       |                                    |                                                              |                                                              |
| **1103** **Integer Factorization**      | [C++](/AdvancedLevel/C++/1103.cpp) | 1. 利用`vector`(**可根据`size`函数确认符合要求的元素个数**)，**预先存储所有 ≤ N的 元素(整数的P次幂值)**<br />2. **为了保证底数最大的序列被选中，从大到小遍历**<br />3. DFS函数的参数：**当前**元素下标，**已选**元素数量，**已选**元素之和，**已选**元素的底数之和<br />4. DFS函数的**递归边界**：已选元素数量为K且和为N<br />5. DFS函数的**递归调用**：**选择当前元素和不选择当前元素**<br />6. **剪枝**：**和超过N 或 已选元素数量超过K 或 遍历完底数序列**时，不必再递归 | 深度优先搜索DFS + 剪枝                                       |